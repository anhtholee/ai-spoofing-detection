# DATACARD: AI Spoofing Detection Dataset

This document outlines the data schema for a synthesized dataset of transaction-like events from a hypothetical Android SDK. The primary purpose of this dataset is to train a model to detect location spoofing.

## Data Schema

The schema consists of two identifiers (`event_id`, `installation_id`) and 15 features that a modern Android SDK on a mid-range device can collect or infer. These features go beyond basic geolocation to provide a richer context for detecting anomalies.

| Field Name              | Type    | Range / Example                               | Source/Inference Method                                                                                                                                                             | Anti-Spoofing Rationale                                                                                                                                                                   |
| ----------------------- | ------- | --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **event_id**            | String  | UUID (e.g., `123e4567-e89b-12d3-a456-426614174000`) | Generated uniquely for each event.                                                                                                                                                  | Primary key for tracking and referencing individual events.                                                                                                                               |
| **installation_id**     | String  | UUID (e.g., `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`) | A UUID generated and stored locally on the client device during the first application launch.                                                                                     | Groups all events from a single app installation, allowing for the sequential analysis of a device's behavior over time. Crucial for detecting patterns like teleportation or replays.     |
| **latitude**            | Float   | -90.0 to 90.0                                 | `Location.getLatitude()` from Android's Fused Location Provider.                                                                                                                    | Core location data. Anomalous jumps or paths are primary indicators.                                                                                                                      |
| **longitude**           | Float   | -180.0 to 180.0                               | `Location.getLongitude()` from Android's Fused Location Provider.                                                                                                                   | Core location data. Anomalous jumps or paths are primary indicators.                                                                                                                      |
| **timestamp_unix**      | Integer | Unix Epoch (e.g., `1672531199`)                 | `System.currentTimeMillis() / 1000` captured at the time of the location event.                                                                                                     | Provides the temporal sequence of events. Essential for analyzing the velocity and plausibility of movement between points.                                                              |
| **horizontal_accuracy** | Float   | > 0.0 (meters) (e.g., `5.0`)                  | `Location.getAccuracy()` from the Fused Location Provider.                                                                                                                          | Spoofed locations often have fixed, unnaturally low (i.e., "perfect") accuracy values. Genuine signals exhibit variable accuracy based on environmental factors (buildings, weather).   |
| **altitude**            | Float   | Meters (e.g., `150.5`)                        | `Location.getAltitude()` from GPS, or can be inferred from the barometer (`pressure_hpa`).                                                                                        | Sudden, physically impossible changes in altitude (e.g., 1000m in one second) are strong indicators of spoofing. Cross-validation with barometric pressure adds robustness.                |
| **speed**               | Float   | >= 0.0 (m/s) (e.g., `1.2`)                    | `Location.getSpeed()` from the Fused Location Provider.                                                                                                                             | Unrealistic speeds (e.g., exceeding the speed of sound) or impossible acceleration/deceleration between points are clear signs of spoofing.                                            |
| **bearing**             | Float   | 0.0 to 360.0 (degrees)                        | `Location.getBearing()` from the Fused Location Provider.                                                                                                                           | The direction of travel. While a user can change direction instantly, a sequence of events showing erratic bearing changes that don't align with speed can be suspicious.                 |
| **pressure_hpa**        | Float   | ~950 to 1050 hPa (e.g., `1013.25`)              | `Sensor.TYPE_PRESSURE`. Requires a barometer, which is common in mid-range and high-end phones.                                                                                   | Corroborates altitude data. A location change suggesting a 500m altitude gain should be accompanied by a corresponding drop in atmospheric pressure. A mismatch is a strong anomaly signal. |
| **mock_location_enabled** | Boolean | `true` / `false`                              | `Location.isFromMockProvider()` on the location object itself. This is a direct flag provided by the Android OS.                                                                    | The most direct and explicit indicator of spoofing. If this is `true`, the location data is being programmatically supplied and cannot be trusted.                                       |
| **device_is_charging**  | Boolean | `true` / `false`                              | `BatteryManager.isCharging()`. Can be obtained by listening to battery state intents.                                                                                               | While not a definitive proof, many spoofing methods (especially for development or fraud) are operated from a computer, meaning the device is likely to be charging.                    |
| **wifi_bssid**          | String  | MAC Address (e.g., `0a:1b:2c:3d:4e:5f`) or `null` | `WifiInfo.getBSSID()` via the `WifiManager`. Requires `ACCESS_WIFI_STATE` permission.                                                                                               | Provides a physical anchor. If the device's location "teleports" several kilometers but the connected WiFi BSSID remains the same, it's a near-certain sign of spoofing.                  |
| **cell_tower_id**       | String  | e.g., `MCC:MNC:LAC:CID` or `null`             | `TelephonyManager.getAllCellInfo()` and extracting IDs (`CellIdentityGsm`, `CellIdentityLte`, etc.). Requires `ACCESS_FINE_LOCATION` permission.                                    | Similar to `wifi_bssid`, this anchors the device to a physical cell tower. A location jump without a corresponding change in the serving cell tower is highly suspicious.                 |
| **num_satellites**      | Integer | 0 to ~30 (e.g., `12`)                         | `GnssStatus.Callback` provides satellite metadata, including the count of satellites used in the fix.                                                                             | Mock location providers may not simulate satellite data realistically. They might report a fixed, high number of satellites, whereas a real device's satellite count will fluctuate.        |
| **vertical_accuracy**   | Float   | > 0.0 (meters) (e.g., `10.0`)                 | `Location.getVerticalAccuracyMeters()` (available from API 26+).                                                                                                                    | Similar to `horizontal_accuracy`, spoofed locations may have an unnaturally consistent or perfect vertical accuracy, which is rare in genuine GPS signals.                               |
| **ambient_light_lux**   | Float   | >= 0.0 (e.g., `450.0`)                        | `Sensor.TYPE_LIGHT`. Requires a light sensor.                                                                                                                                       | Provides environmental context. A device reporting a location on a sunny beach at noon should have a high lux value. If it reports a low value (indicating a dark room), it's a mismatch. |

## Hypothetical Data Distribution

For the purpose of synthesizing a dataset:
- **Real Events (80%):** Data would be generated to simulate realistic user behavior. This includes walking, driving in a car, and staying in one place (home/office). Sensor data (`pressure_hpa`, `ambient_light_lux`) would be correlated with the simulated context (e.g., pressure and altitude change together; light levels are stable indoors). `mock_location_enabled` would be `false`.
- **Spoofed Events (20%):**
    - **Teleportation (10%):** Abrupt, large jumps in `latitude` and `longitude` with physically impossible `speed`. `wifi_bssid` and `cell_tower_id` would likely remain constant across the jump, creating a strong anomaly signal.
    - **Bot/Replay Attack (10%):** A predefined, "perfect" path is replayed. `horizontal_accuracy` and `vertical_accuracy` might be suspiciously constant and low. `bearing` and `speed` changes might be too smooth and predictable. `num_satellites` might be fixed. `mock_location_enabled` would be `true`.

## Limitations

1.  **Permission-Dependent:** Collection of many of these features (`wifi_bssid`, `cell_tower_id`, location itself) is dependent on the user granting appropriate permissions. The absence of this data does not imply spoofing.
2.  **Hardware-Dependent:** Features like `pressure_hpa`, `ambient_light_lux`, and `vertical_accuracy` require specific sensors or OS versions that may not be present on all devices.
3.  **Inference vs. Ground Truth:** Some fields like `cell_tower_id` can be complex to interpret and may not always be available or stable, especially in areas with poor reception.
4.  **Privacy:** The collection of this data must be handled in accordance with privacy policies (e.g., GDPR, CCPA) and platform guidelines. The schema is designed for a security context where such monitoring is disclosed and justified.